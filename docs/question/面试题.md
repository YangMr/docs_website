# 面试题

## 九、JAVASCRIPT面试题

### 9.1 深拷贝与浅拷贝

##### 浅拷贝: 

主要拷贝的是对象的引用值，当改变对象的值，另一个对象的值也会发生变化, 而且使用浅拷贝拷贝引用数据类型时, 不会在堆中开辟新的内存空间

##### 深拷贝: 

主要是将另一个对象的属性值拷贝过来之后，修改另一个对象的属性值并不受到影响，它自己在堆中开辟了自己的内存区域，不受外界干扰, 而且使用深拷贝时, 不仅会在堆内存当中去开辟新的空间, 并且会把原数据拷贝到新的空间中, 同时,栈中也会开辟新的空间, 保存的拷贝的引用地址, 这样就可以实现深拷贝.

#### 9.1.2 如何实现浅拷贝? 

引用数据只有一层时: 

- 示例1

  ```javascript
  var obj = { name: "jack" };
  var t ={}
  
  t.name = "123";
  console.log(obj);
  console.log(t);
  ```

引用数据有多层时: 

- Object.assign
- 创建新对象,重新赋值

#### 9.1.3 如何实现深拷贝? 

引用数据只有一层时: 

- 示例1: Object.assign 

  ```
   var tt = { name: "hahha", test: { id: 1, msg: "hello" } };
        var nn = {};
        Object.assign(nn, tt);
        nn.name = 111;
        nn.test.msg = "aa";
        console.log("nn=>", nn);
        console.log("tt", tt);
  ```

- 示例2: 创建一个新对象,将原数据遍历添加到新对象中

  ```
  var obj = { name: "jack", test: { id: 1, msg: "hello" } };
  
        function p(obj) {
          var o = {};
  
          for (var i in obj) {
            console.log(i);
            o[i] = obj[i];
          }
  
          return o;
        }
  
        var a = p(obj);
  ```



引用数据有多层时: 

- Json.stringifyt + json .parse()  

  ```
  存在的问题: 
  1. 当数据结构复杂时, 无法进行深拷贝
  2. 如果数组里面有 functin、null、undefined 是无法进行拷贝
  ```

  

- 检测数据类型 + 深拷贝 + 创建新数组和对象 

```javascript
 // 判断拷贝数据的类型 基本数据类型 引用数据类型
      // object array
      // object 创建一个新对象,将原对象的数据遍历放到新对象
      // array 创建一个新数组, 将原数组的数据遍历放到新数组
      // 检测数据类型方法
      function getDataType(arg) {
        // 检测变量的数据类型
        let dataType = Object.prototype.toString.call(arg); // [object String]

        let mapType = {
          "[object Boolean]": "boolean",
          "[object Number]": "number",
          "[object String]": "string",
          "[object Function]": "function",
          "[object Array]": "array",
          "[object Date]": "date",
          "[object RegExp]": "regExp",
          "[object Undefined]": "undefined",
          "[object Null]": "null",
          "[object Object]": "object",
        };

        return mapType[dataType];
      }

      function cloneDeep(origin) {
        // 检测传递的变量属于什么数据类型
        const type = getDataType(origin);

        if (type === "object") {
          var obj = {};
          for (var key in origin) {
            if (getDataType(origin[key]) === "object") {
              obj[key] = cloneDeep(origin[key]);
            } else if (getDataType(origin[key]) === "array") {
              obj[key] = cloneDeep(origin[key]);
            } else {
              obj[key] = origin[key];
            }
          }
          return obj;
        }

        if (type === "array") {
          var array = [];
          for (var i = 0; i < origin.length; i++) {
            if (getDataType(origin[i]) === "array") {
              array.push(cloneDeep(origin[i]));
            } else if (getDataType(origin[i]) === "object") {
              array.push(cloneDeep(origin[i]));
            } else {
              array.push(origin[i]);
            }
          }
          return array;
        }

        return origin;
      }
```

- 第三方的库 lodash.js
  `_.cloneDeep`



### 9.2 防抖与节流

#### 9.2.1 什么是防抖?

定义: 在事件被触发n秒后在执行回调,如果在这n秒内又被重新触发,则重新计时

```javascript
let oIpt = document.getElementById('ipt');

    let time = null;

    function debounce (handle, delay) {

        let time = null;

        return function () {

            let self = this,arg = arguments;

            clearTimeout(time);

            time = setTimeout(function () {

                handle.apply(self,arg);　　//this绑定

            },delay)

        }

    }

    function ajax (e) {

        console.log(e,this.value)

    }

    oIpt.oninput = debounce(ajax, 1000)  //1s后发出请求
```



#### 9.2.2 什么是节流?

定义:规定在一个单位时间内,只能触发一次函数, 如果这个单位时间内触发多次函数, 只有一次生效.

```javascript
<button id='show'>抢购</button>

<div id="box">0</div>

JS: 1 let oBtn=document.getElementById('show');

    let oBox=document.getElementById('box');

    /*

        handle:buy函数

        wait:规定在一秒钟内只能执行一次

    */

    function throttle (handle, wait) {

        let lastTime = 0;

        return function (e) {

            let nowTime = new Date().getTime()

            if (nowTime - lastTime > wait) {

                handle();

                lastTime = nowTime;

            }

        }

    }

    function buy(){

        oBox.innerText = parseInt(oBox.innerText)+1

    }

    oBtn.onclick = throttle(buy, 1000)
```

#### 9.2.3 使用场景

节流场景：窗口调整(resize)、页面滚动(scroll)、抢购疯狂点击(movedown)

防抖场景: 实时搜索(keyup)、拖拽(mousemove)



#### 9.2.4 实际开发

借助第三方库 : `lodash.js`



### 9.3 宏任务与微任务

#### 9.3.1 同步和异步是怎么来的 ? 

js是一个单线程的语言, 单线程语言的特点同一时间只能做一件事情, 所以js会开启一个任务队列,这个任务队列里面所有任务需要排队，前一个任务结束，才会执行后一个任务,如果前一个任务耗时很长，后一个任务就不得不一直等着, 这样就会导致我们进行阻塞, 于是，js将所有的任务可以分成了两种,分别是同步 与 异步



同步任务与异步任务在哪里执行:

- 同步任务是在主线程上执行, 并且会产生一个执行栈
- 异步任务不进入主线程, 而进入"任务队列"（task queue）某个异步任务可以执行了，该任务才会进入主线程执行



任务队列里面的任务如何才能进入到执行栈中: 

异步代码  宿主环境 -》 进入到任务队列 -〉   任务队列里面的任务  如何才能进行到执行栈 -》 任务队列有没有事件, 如果有事件, 那么对应的任务就可以进入到执行栈



- 有没有产生事件
- 有没有回调函数

#### 9.3.2 宏任务与微任务是如何产生的?

js将程序划分为同步与异步, 同时, js又将异步任务进行了进一步发的划分,分别划分为宏任务 以及 微任务



#### 9.3.3 什么是宏任务? 什么是微任务? 

宏任务与微任务都属于异步任务, 当程序执行的时候,我们会判断当前的任务是宏任务还是微任务,如果是属于微任务,它会先执行微任务, 然后执行宏任务, 如果宏任务里面有微任务,他会优先执行内部所有的微任务



#### 9.3.4 宏任务与微任务都有哪些方法?

宏任务:

- 定时器
- ajax请求,axios
- 读取文件



微任务:

- promise.then .catch .finally
- $nextTick
- ...



#### 9.3.5 宏任务与微任务执行的顺序

ajax - > 定时器 -> (ajax) -> .then -> new promise -> .then -> console.log

```
// 常规的情况下, 先执行同步 -》 异步 -》 微任务 -》 宏任务 -》 
```



### 9.4 实现数组去重?最少写出三种方法?

> indexof
>
> 
>
> var arr = [1,1,1,1,2,3,4,5,6];
>
> var temp= [];
>
> for(var i=0;i<arr.length;i++){
>
> ​	if(temp.indexof(arr[i] == -1)){
>
> ​		temp.push(arr[i])s
>
> ​	}
>
> }
>
> 
>
> set
>
> new Set(arr)
>
> 
>
> 双层for循



### 9.5 什么是递归?如何用代码实现递归?

> 函数本身调用自身,满足对应的条件则进行停止 
>
> 1. 必须需要有结束条件
> 2. 父集与子集做的事情是同样的事情

```html
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title></title>
  </head>
  <body>
    <script>
      let menuList = [
        {
          id: 1,
          parentId: null,
          name: "用户"
        },
        {
          id: 2,
          parentId: null,
          name: "系统"
        },
        {
          id: 3,
          parentId: 1,
          name: '员工管理'
        },
        {
          id: 4,
          parentId: 2,
          name: '系统管理'
        },
        {
          id: 5,
          parentId: 3,
          name: '正式员工'
        },
        {
          id: 6,
          parentId: 4,
          name: '设备管理'
        }
      ]



      function formatToTree(menu) {
        // 1. 获取一级菜单数据
        // 2. 非一级菜单数据
        let parent = menu.filter(item => item.parentId === null)
        let children = menu.filter(item => item.parentId !== null)

        deepData(parent, children)

        function deepData(parent, children) {
          parent.map(p => {
            console.log("p=>", p)
            delete p.parentId
            children.map(c => {
              
      
              if (p.id === c.parentId) {
                
                const _c = JSON.parse(JSON.stringify(children))
                deepData([c],_c)
                
                if (p.children) {
                  p.children.push(c)
                } else {
                  p.children = [c]
                }
              }
            })
          })
          
        }
        return parent
      }

      console.log("result=>", formatToTree(menuList))
    </script>
  </body>
</html>
```



### 9.6 请说出实现冒泡排序的思路?

> 1. 比较相邻的两个元素，如果前一个比后一个大，则交换位置。
>    2、比较完第一轮的时候，最后一个元素是最大的元素。
>    3、这时候最后一个元素是最大的，所以最后一个元素就不需要参与比较大小。
> 2. 双层for循环
> 3. 外层 条件判断使用数组长度 - 1
> 4. 内层是 - 1 - i
> 5. 相邻元素进行比较 ,然后再进行两两交换
>
> ```go
> function bSort(arr) {
>   var len = arr.length; // 5
>   for (var i = 0; i < len-1; i++) { // 4 
>     for (var j = 0; j < len - 1 - i; j++) { // 5 - 1 - 0 = 4
>          // 相邻元素两两对比，元素交换，大的元素交换到后面
>         if (arr[j] > arr[j + 1]) {
>             var temp = arr[j]; // 20
>             arr[j] = arr[j+1];  // 18
>             arr[j+1] = temp;
>         }
>     }
>   }
>   return arr;
> }
> 
> //举个数组
> myArr = [20,18,27,19,35];
> 
> //使用函数
> bSort(myArr)
> ```

### 9.7  如何改变函数内部的this指针的指向?(60%)

> call apply bind
>
> 区别?
>
> call和apply改变了函数的this上下文后便执行该函数,而bind则是返回改变了上下文后的一个函数。
>
> 他们俩之间的差别在于参数的区别，call和apply的第一个参数都是要改变上下文的对象，而call从第二个参数开始以参数列表的形式展现，apply则是把除了改变上下文对象的参数放在一个数组里面作为它的第二个参数。

